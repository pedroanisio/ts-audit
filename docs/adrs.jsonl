{"id":"ADR-001","title":"Module System","status":"approved","decision":"ES Modules (ESM) over CommonJS","rationale":"Modern standard, better tree-shaking, native top-level await support","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-002","title":"TypeScript Strict Mode","status":"approved","decision":"strict: true enabled in tsconfig","rationale":"Catches bugs at compile time, enforces explicit types, prevents implicit any","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-003","title":"Testing Framework","status":"approved","decision":"Vitest over Jest","rationale":"Native ESM support, faster execution, TypeScript out of the box, compatible API","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-004","title":"Code Markers Convention (TODO, FIX, HACK, etc.)","status":"approved","decision":"We adopt a two-tier marker system for code annotations. Tier 1 uses short-lived inline markers (TODO, FIXME, HACK, XXX) that are only allowed during active development and must be resolved or promoted to structured metadata before a PR is merged. Tier 2 uses persistent structured entries in __metadata.todos and __metadata.fixes for any work, enhancement, or defect that should outlive the current work session. We standardize marker semantics, priority/severity levels, ID formats (TODO-NNN, FIX-NNN), lifecycle and retention policies, forbidden markers, and a PR checklist, and we rely on ts-introspect (including rules like metadata/untracked-todos) and tsi CLI commands to enforce and report on these conventions.","rationale":"Unstructured code markers like TODO, FIXME, HACK, and XXX tend to accumulate over time without ownership, priority, or clear lifecycle, creating invisible technical debt, noise in the codebase, and lack of accountability. Different teams and individuals use arbitrary comment formats, making it difficult to search, aggregate, or reason about outstanding work and known defects. Since ts-introspect already provides structured metadata capabilities, adopting a standardized two-tier model enables us to keep code clean while still tracking long-lived work in a queryable and reportable form. This balances the need for lightweight, local notes during development with the requirement for durable, structured tracking across the project.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["code-markers","todo","fixme","technical-debt","ts-introspect","conventions"],"context":"Code markers like TODO, FIXME, HACK, and XXX are widely used in our codebase but, without conventions, they lead to lost context, invisible technical debt, stale comments, lack of ownership, and inconsistent searchability. We now have ts-introspect, which can track todos and fixes via __metadata. To leverage this system effectively, we need clear rules for when to use inline markers vs. structured metadata, how to prioritize and classify work, and how to ensure markers do not become permanent clutter in the source code.","consequences":{"positive":["All planned work and known defects are captured in structured metadata and can be queried via the tsi CLI and reports.","Ownership, priority, severity, and lifecycle of todos and fixes are explicit, improving accountability and planning.","Inline comments remain clean and focused on local code readability, avoiding long-lived, stale markers.","HTML and other reports can be generated from __metadata to support planning, dashboards, and reviews.","Pre-commit hooks and metadata/untracked-todos validation rules can automatically catch violations and enforce the conventions.","IDE snippets and templates can make metadata entry fast, making the workflow natural during development."],"negative":["Developers must spend additional effort promoting inline markers into structured metadata when work needs to persist.","There is a learning curve for the team to internalize the new marker taxonomy, ID conventions, and lifecycle rules.","The workflow depends on ts-introspect and related tooling; if tooling is misconfigured or unavailable, the process weakens.","If the conventions are not followed consistently, we risk divergence between inline comments, metadata, and actual code state."]}}
{"id":"ADR-005","title":"Async File Operations","status":"approved","decision":"fs/promises over sync APIs","rationale":"Non-blocking I/O, better for scaling in server context, modern async/await pattern","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-006","title":"Development Runtime","status":"approved","decision":"tsx for development execution","rationale":"Fast TypeScript execution without separate compile step, ESM support, minimal config","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-007","title":"Node.js Version","status":"approved","decision":"Node.js 22.x LTS","rationale":"Stable LTS release, native ESM, modern V8 engine, long-term support until 2027","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-008","title":"Package Manager","status":"approved","decision":"pnpm 9.x over npm/yarn","rationale":"Fast, disk-efficient, strict dependencies, better monorepo support","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-009","title":"Linter and Formatter","status":"approved","decision":"Biome 1.9+ over ESLint/Prettier","rationale":"All-in-one lint and format, fast Rust-based, TypeScript-native, zero config","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-010","title":"Build Tool","status":"approved","decision":"tsc + Vite for production builds","rationale":"tsc compiles server/shared code, Vite bundles client code, simple and effective for current project size, no additional tooling needed","createdAt":"2025-11-27","updatedAt":"2025-11-28"}
{"id":"ADR-011","title":"Git Hooks","status":"approved","decision":"simple-git-hooks 2.x over husky","rationale":"Lightweight, no bloat, simple configuration, zero dependencies","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-012","title":"Runtime Validation","status":"deferred","decision":"Zod 3.x for schema validation when needed","rationale":"Runtime type validation, TypeScript inference, composable schemas. Deferred until API endpoints or external data parsing requires validation","createdAt":"2025-11-27","updatedAt":"2025-11-28"}
{"id":"ADR-013","title":"TypeScript File Introspection System","status":"approved","decision":"ts-introspect with __metadata exports for structured code documentation","rationale":"Enables structured metadata for todos, fixes, and documentation. Provides queryable code annotations via tsi CLI. Supports ADR-004 code markers convention. Generates reports for planning and reviews","createdAt":"2025-11-27","updatedAt":"2025-11-28"}
{"id":"ADR-014","title":"Logging Library","status":"approved","decision":"tslog over console.log/pino/winston","rationale":"TypeScript-native with full type safety, zero dependencies, structured JSON logging, pretty console output, minimal config, tree-shakeable","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-015","title":"Frontend Dev Server","status":"approved","decision":"Vite for frontend development and build","rationale":"Hot module replacement, native TypeScript support, fast esbuild-powered bundling, separate HTML/CSS/JS files with proper syntax highlighting, production-ready builds","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-016","title":"Project Folder Structure","status":"approved","decision":"src/{client,server,shared} with separate tests/ directory","rationale":"Clear separation of browser/Node.js runtimes, shared code for cross-environment types, tests mirror src structure for discoverability, client built by Vite, server+shared built by tsc","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-017","title":"Shared Components Architecture","status":"approved","decision":"All Blueprint UI features must be created as shared components in src/client/components/blueprints/shared/","rationale":"Eliminates code duplication between Editor and Viewer modes, ensures consistent styling via ui-constants.ts, single source of truth for UI components (Toolbar, StructureTree, CollapsibleSection, Inspector, PropertyPanel, ColorPicker, FileLoader, TemplateSelector), faster development through reuse, easier maintenance with bug fixes in one place","createdAt":"2025-11-28","updatedAt":"2025-11-28"}
{"id":"ADR-018","title":"Icon Library","status":"approved","decision":"Lucide React icons over emojis or other icon libraries","rationale":"Consistent icon font rendering across all platforms, tree-shakeable individual icon imports, TypeScript-native with full type safety, lightweight bundle size, MIT licensed, compatible with React ecosystem, no emoji rendering inconsistencies across browsers/OSes","createdAt":"2025-11-28","updatedAt":"2025-11-28"}
{"id":"ADR-019","title":"Dead Code Detection","status":"approved","decision":"Knip for finding unused files, dependencies, and exports","rationale":"Modern comprehensive tool for detecting dead code, finds unused files/dependencies/exports/types, excellent monorepo and React support, integrates with TypeScript project references, configurable via knip.json, supports barrel file entry points for public APIs","createdAt":"2025-11-28","updatedAt":"2025-11-28"}
{"id":"ADR-020","title":"Code Quality and Project Practices","status":"approved","decision":"Adopt DRY, SOLID principles, Design Patterns, and Architectural Elegance while prioritizing Ship Fast philosophy","rationale":"Sustainable, maintainable code requires adherence to proven engineering principles balanced with pragmatic delivery goals","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["code-quality","best-practices","architecture","engineering-principles"],"context":"As the codebase grows, maintaining consistency and quality becomes critical. Without clear guidelines, technical debt accumulates, onboarding slows, and the system becomes brittle. We need explicit principles that guide daily decisions without over-engineering.","consequences":{"positive":["Consistent codebase that any team member can navigate and extend","Reduced bugs through proper abstractions and separation of concerns","Faster feature development through reusable, well-designed components","Easier code reviews with shared vocabulary and expectations","Sustainable velocity over time"],"negative":["Initial learning curve for team members unfamiliar with these principles","Risk of over-engineering if principles are applied dogmatically","Requires ongoing vigilance and code review discipline"]},"principles":{"DRY":"Don't Repeat Yourself - Extract common logic into shared utilities, components, and modules. Every piece of knowledge should have a single, authoritative representation. Duplication is the root of maintenance nightmares.","SOLID":{"S":"Single Responsibility - Each module, class, or function should have one reason to change. Keep units focused and cohesive.","O":"Open/Closed - Code should be open for extension but closed for modification. Use composition, interfaces, and dependency injection.","L":"Liskov Substitution - Subtypes must be substitutable for their base types without altering correctness. Honor contracts.","I":"Interface Segregation - Prefer small, focused interfaces over large, monolithic ones. Clients should not depend on methods they don't use.","D":"Dependency Inversion - Depend on abstractions, not concretions. High-level modules should not depend on low-level modules."},"DesignPatterns":"Apply proven design patterns (Factory, Strategy, Observer, Decorator, etc.) where they genuinely simplify code. Patterns are tools, not goals - use them to solve real problems, not to demonstrate cleverness.","ArchitecturalElegance":"Strive for clean, intuitive architecture that reveals intent. Code should be self-documenting through clear naming, logical structure, and minimal surprise. Complexity should be encapsulated, not scattered. The architecture should guide developers toward the pit of success.","ShipFast":"Perfect is the enemy of good. Deliver working software iteratively. Avoid over-engineering and premature optimization. Make pragmatic tradeoffs - 80% solution today beats 100% solution never. Refactor when patterns emerge, not in anticipation. Technical excellence enables speed; it doesn't compete with it."}}
{"id":"ADR-100","title":"Direct Manipulation Primacy","status":"approved","decision":"Every visual element that can be edited MUST be directly manipulable on the canvas. Property panels are secondary.","rationale":"Users choose Figma over competitors because they can grab anything and move it. The canvas is the source of truth. If a user has to hunt through panels to change something they can see, we've failed.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","ux","interaction","foundational"],"priority":"foundational","testQuestion":"Can you drag it?"}
{"id":"ADR-101","title":"Live Code Output","status":"approved","decision":"The generated code (CSS, HTML, framework code) MUST be visible at all times and update in real-time as the user manipulates the layout.","rationale":"Developers use layout tools to get code. If they can't see the code until export, they can't learn, verify, or trust the output. Layoutit and CSS Grid Generator succeed because the code panel is always visible.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","export","code","foundational"],"priority":"foundational","testQuestion":"Can you see the code change?"}
{"id":"ADR-102","title":"Instant Visual Feedback","status":"approved","decision":"Every user action MUST produce immediate visual feedback within 16ms (one frame). No action should feel sluggish or require waiting.","rationale":"Professional tools feel instant. Lag destroys the illusion of direct manipulation. If dragging a panel feels slow, users will distrust the tool.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","performance","ux","foundational"],"priority":"foundational","testQuestion":"Does it feel instant?","performanceBudget":{"hoverFeedback":"<16ms","dragUpdate":"<16ms","propertyChange":"<50ms","patternLoad":"<500ms"}}
{"id":"ADR-103","title":"Undo Everything","status":"approved","decision":"Every user action that modifies state MUST be undoable. Undo history must be visible and navigable.","rationale":"Fear of making mistakes prevents experimentation. Users who can freely undo will try more things, learn faster, and trust the tool more. Figma's infinite undo is a key differentiator.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","state","ux","foundational"],"priority":"foundational","testQuestion":"Can you Ctrl+Z this?"}
{"id":"ADR-104","title":"Progressive Disclosure","status":"approved","decision":"Simple things must be simple. Advanced features must be accessible but not in the way. The UI must scale from beginner to expert.","rationale":"New users are overwhelmed by complexity. Experts are frustrated by hidden features. Progressive disclosure shows basics by default, reveals advanced options on demand.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","ux","design","foundational"],"priority":"foundational","testQuestion":"Is simple stuff simple?"}
{"id":"ADR-105","title":"Production-Ready Export","status":"approved","decision":"Exported code MUST be production-ready. No cleanup, reformatting, or manual fixes should be required before using the output in a real project.","rationale":"If users have to fix the exported code, they'll question why they used the tool. The code must be as good as what a senior developer would write by hand.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","export","quality","foundational"],"priority":"foundational","testQuestion":"Would you ship this code?"}
{"id":"ADR-106","title":"Accessibility Native","status":"approved","decision":"Accessibility is not an afterthought. The editor itself must be accessible, and the output it generates must be accessible by default.","rationale":"Many users have disabilities. Accessible design improves usability for everyone. Accessibility debt is expensive to fix later.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","accessibility","inclusive","foundational"],"priority":"foundational","testQuestion":"Can you use it without a mouse?"}
{"id":"ADR-107","title":"Performance Budget","status":"approved","decision":"The application has a strict performance budget. Features that exceed the budget must be optimized or rejected.","rationale":"Performance degrades gradually then suddenly. Without a budget, death by a thousand cuts. A budget forces tradeoffs.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","performance","quality","foundational"],"priority":"foundational","testQuestion":"Is it under budget?","performanceBudget":{"initialLoadFCP":"<1.5s","timeToInteractive":"<3s","bundleSizeJS":"<200KB gzip","bundleSizeCSS":"<30KB gzip","memoryIdle":"<50MB","memory100Zones":"<150MB","dragOperation":"60fps"}}
{"id":"ADR-108","title":"Extensibility Architecture","status":"approved","decision":"The core must be minimal and stable. Features are built through a plugin/extension architecture. Third parties can extend without forking.","rationale":"Core changes are risky; plugins are isolated. Different users need different features. Community can contribute without core access.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","architecture","extensibility","foundational"],"priority":"foundational","testQuestion":"Could this be a plugin?"}
{"id":"ADR-109","title":"Design System Fidelity","status":"approved","decision":"The editor must use a consistent design system. Every component follows the same visual language. Tokens are the source of truth.","rationale":"Inconsistent UI looks unprofessional and confuses users. A design system ensures visual coherence, speeds development, and makes theming possible.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","design","ui","foundational"],"priority":"foundational","testQuestion":"Are you using tokens?"}
{"id":"ADR-110","title":"State Persistence and Recovery","status":"approved","decision":"User work must never be lost. State persists across sessions. Recovery from crashes is automatic.","rationale":"Losing work destroys trust. Users will not commit to a tool that might lose their layouts. Auto-save and recovery are table stakes for professional tools.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","state","reliability","foundational"],"priority":"foundational","testQuestion":"Will this survive a crash?"}
{"id":"ADR-111","title":"Testing Strategy and Quality Gates","status":"approved","decision":"Enforce minimum coverage thresholds (70% statements, 65% branches, 75% functions, 70% lines), require tests for all new code, run automated quality gates on every PR via CI.","rationale":"Without enforced quality gates, technical debt accumulates silently. Coverage metrics provide objective quality signals. Automated CI catches issues before merge. Critical paths require 95% coverage.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["testing","quality","ci","coverage","infrastructure"],"testQuestion":"Do all tests pass? Is coverage above threshold?","coverageThresholds":{"statements":70,"branches":65,"functions":75,"lines":70,"criticalPaths":95},"testCategories":["unit","component","integration","accessibility","performance"],"qualityGates":{"preCommit":["lint","test:quick"],"prePush":["test","check"],"pullRequest":["lint","typecheck","test:coverage","build","bundleSize"],"nightly":["test:a11y","test:perf","knip","audit"]}}
{"id":"ADR-112","title":"Design Token Architecture","status":"approved","decision":"Design tokens have a single source of truth in TypeScript (design-tokens.ts). Global CSS variables live in styles.css only. Component-specific styles are scoped via data-attributes (e.g., [data-blueprint]). STYLES object pattern preferred over CSS Modules for type safety.","rationale":"Single source eliminates drift. TypeScript provides type safety. Data-attribute scoping provides encapsulation without CSS Modules overhead. Professional tools (Figma, VS Code, Linear) use similar patterns. Tailwind kept only for code export generation feature.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["core","design-system","tokens","styling","foundational"],"priority":"foundational","testQuestion":"Is it from design-tokens.ts?","architecture":{"sourceOfTruth":"src/client/design-tokens.ts","globalStyles":"src/client/styles.css","componentStyles":"Scoped via [data-*] selectors in component CSS files","derivedFiles":["src/client/styles.css","src/client/components/blueprints/blueprint.css","src/client/components/blueprints/shared/ui-constants.ts","src/client/components/blueprints/tokens.ts"]},"cssLayers":{"layer1_reset":"CSS reset and base styles","layer2_tokens":"CSS custom properties from design-tokens.ts","layer3_utilities":"Utility classes (.flex, .btn, etc.)","layer4_components":"Component-specific styles scoped via [data-*]"},"tokenCategories":["COLORS_BG","COLORS_TEXT","COLORS_ACCENT","BORDER_COLORS","FONTS","FONT_SIZES","SPACING","SHADOWS","TRANSITIONS","Z_INDEX","LAYOUT"],"stylingPatterns":{"preferred":"STYLES object pattern with CSSProperties type","acceptable":"CSS utility classes for static patterns","componentScoping":"[data-blueprint] and similar data-attribute selectors","avoid":"Inline magic numbers, hardcoded colors, duplicate CSS variables"},"tailwindUsage":"Code export generation ONLY - not for main UI styling","scripts":{"generate":"npm run tokens:generate","verify":"npm run tokens:verify"},"consequences":{"positive":["Single source of truth eliminates value drift","Type-safe tokens catch typos at compile time","Data-attribute scoping provides encapsulation","No CSS Modules build overhead","Matches patterns used by professional tools"],"negative":["Manual sync required when adding new tokens","Learning curve for STYLES object pattern","Requires discipline in code reviews"]}}
{"id":"ADR-113","title":"Style Enforcement Architecture","status":"approved","decision":"All styling code MUST pass automated validation at build time. Violations MUST block CI and require explicit override. Rules: no magic colors (use COLORS_* tokens), no magic pixels (use SPACING tokens), STYLES object pattern required for static styles, token imports enforced.","rationale":"Design token system exists (637 lines) but analysis reveals 270 inline style instances, 488 magic pixel values, 122 magic color values, 51% of components don't import tokens, and zero build-time enforcement. ADR-112 established architecture but lacks enforcement mechanisms.","createdAt":"2025-11-29","updatedAt":"2025-11-30","tags":["core","design-system","enforcement","linting","ci","styling"],"priority":"high","testQuestion":"Does npm run lint:styles pass?","supersedes":null,"relatedADRs":["ADR-102","ADR-106","ADR-109","ADR-112"],"rules":{"noMagicColors":"All color values must reference COLORS_* tokens from design-tokens.ts","noMagicSpacing":"All spacing values must use SPACING[n] tokens","noRawPixels":"Pixel values only permitted in token definition files (design-tokens.ts, tokens.ts)","stylesPattern":"Static styles must use STYLES object pattern; inline style={{}} only for dynamic computed values","tokenImports":"Files with style definitions must import from token sources","cssModuleThresholds":">10 style rules, :hover/:focus, media queries, or keyframes should use CSS modules"},"eslintRules":{"grid-editor/no-magic-colors":"error","grid-editor/no-magic-pixels":"error","grid-editor/require-token-import":"warn","grid-editor/prefer-styles-object":"warn"},"metrics":{"inlineStyleCount":{"target":"<50","alert":">75"},"magicColorViolations":{"target":0,"alert":">5"},"magicPixelViolations":{"target":0,"alert":">10"},"tokenImportCoverage":{"target":"100%","alert":"<90%"}},"exceptions":{"permitted":["Third-party overrides with eslint-disable comment","Dynamic computed values using token as base","Legacy migration files in .eslint-legacy-styles","Test files (*.test.tsx, *.spec.tsx)"],"overrideProcess":["Add inline comment with reason","Add to .eslint-legacy-styles if bulk migration needed","Create tracking issue for future cleanup","Quarterly review of exceptions"]},"implementationPhases":[{"phase":1,"focus":"Tooling & ESLint rules","duration":"1-2 weeks"},{"phase":2,"focus":"Convert 270 inline styles","duration":"3 weeks"},{"phase":3,"focus":"Bundle reduction","duration":"2 weeks"},{"phase":4,"focus":"CI enforcement & docs","duration":"Ongoing"}],"consequences":{"positive":["All styles derive from single source ensuring consistency","TypeScript catches token typos at compile time","Change token once, updates everywhere improving maintainability","Developers know where to look for values improving discoverability","Verified contrast ratios in tokens for accessibility","Static analysis catches issues pre-runtime"],"negative":["~270 inline styles require initial migration effort","Strictness may slow feature development initially","New developers must learn token system","Legitimate exceptions require justification"]}}
{"id":"ADR-114","title":"Standardized Error Handling with Result Types","status":"approved","decision":"All functions that can fail MUST return Result<T, E> types instead of throwing exceptions, returning null, or returning boolean success flags. Use ok(data) for success, err(error) for failure. Type guards isOk() and isErr() enable type-safe branching.","rationale":"Codebase audit revealed inconsistent error handling: some functions throw, some return null, some return boolean. This creates unpredictable APIs, forces try-catch everywhere, and makes error handling ad-hoc. Result types make failure explicit in the type signature, enable exhaustive error handling, and provide consistent patterns across the codebase.","createdAt":"2025-11-29","updatedAt":"2025-11-29","tags":["core","error-handling","typescript","code-quality","patterns"],"priority":"high","testQuestion":"Does the function return Result<T, E>?","relatedADRs":["ADR-002","ADR-020"],"context":"Code quality audit identified inconsistent error handling as technical debt. Functions like validatePattern() threw errors, resolvePattern() threw errors, fromJSON() threw errors, while tree mutations returned MutationResult and parsing returned ParseResult. This inconsistency made error handling unpredictable and code review difficult.","implementation":{"sourceFile":"src/client/components/blueprints/utils/result.ts","exports":["Result","ResultError","ok","err","isOk","isErr","unwrap","unwrapOr","map","flatMap","fromPromise","fromThrowable","ErrorCodes"],"pattern":"{ success: true; data: T } | { success: false; error: E }"},"migrationStrategy":{"newCode":"All new functions that can fail must return Result<T, E>","existingCode":"Add *Safe() variants returning Result, mark throwing versions @deprecated","throwingFunctions":"Keep for API boundaries where exceptions are expected, implement using Result internally"},"standardErrorCodes":{"NOT_FOUND":"Resource not found","VALIDATION_FAILED":"Input validation failed","INVALID_JSON":"JSON parsing failed","INVALID_INPUT":"Invalid function arguments","INVALID_OPERATION":"Operation not permitted in current state","DUPLICATE_ID":"ID already exists","CIRCULAR_REFERENCE":"Circular dependency detected","NETWORK_ERROR":"Network request failed","TIMEOUT":"Operation timed out"},"consequences":{"positive":["Error handling is explicit in type signatures - no surprises","TypeScript enforces handling of both success and error cases","Consistent pattern across entire codebase","Errors are values that can be transformed, combined, and passed around","No need for try-catch blocks in business logic","Better IDE autocomplete and documentation"],"negative":["More verbose than simple throw/catch for trivial cases","Learning curve for developers unfamiliar with Result pattern","Requires discipline to use consistently","Legacy code needs migration or Safe variants"]},"examples":{"before":"function getUser(id: string): User { if (!users[id]) throw new Error('Not found'); return users[id]; }","after":"function getUser(id: string): Result<User> { if (!users[id]) return err('NOT_FOUND', 'User not found'); return ok(users[id]); }","usage":"const result = getUser('123'); if (isOk(result)) { console.log(result.data); } else { console.log(result.error.message); }"}}